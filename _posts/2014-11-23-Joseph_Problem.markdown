---
layout:     post
published: true
title:      "Joseph问题，经典算法及实现"
subtitle:   "约瑟夫问题，有时也称为约瑟夫斯置换，是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。又称“丢手绢问题”。"
date:       2014-11-23 17:00:00
author:     "ShadowWalker"
header-img: "img/sledgehammer_peak.jpeg"
location:	"Shanghai"
---


> 据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。
> 17世纪的法国数学家加斯帕在《数目的游戏问题》中讲了这样一个故事：15个教徒和15 个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了一个办法：30个人围成一圆圈，从第一个人开始依次报数，每数到第九个人就将他扔入大海，如此循环进行直到仅余15个人为止。问怎样排法，才能使每次投入大海的都是非教徒。

##问题描述

N个人围成一个圈，选定一个小于N的数字M。从一个人开始，1到M报数，报到M的人出列，从下一个人重新开始报数。一直循环，直到所有人出列。

##思路

用程序模拟整个报数的过程，关键在于找出下一个出列的人的下标。这种方式应该算半模拟，半数学分析吧。

通过在纸上列举的方法，不难发现下一个出列的数组下标是<code>idx=(idx+m-1)%len(list)</code>。既在上一次出列元素的后一个开始再往后数m个数就得出下一个出列元素下标，当然还要把数组看成一个环，因此还要加上取模运算。

##Python实现

<pre class="code-container"><code class="python">def joseph_math_solution(n, m):
	list = range(1,n+1)
	idx = 0
	while len(list) is not 0:
		idx=(idx+m-1)%len(list)
		print list.pop(idx)</code></pre>

##算法分析

以上代码总共只有5行，应该算比较精简了。忽然脑中又回响着一句话：人生苦短，请用Python。当然这个问题还会有很多的变种，但是大同小异。

时间复杂度：Ο(n)

空间复杂度：Ο(n)